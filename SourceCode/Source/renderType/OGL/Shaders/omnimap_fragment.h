static char effectomnimap_fragment[] = { 
"#ifdef HAS_OMNIMAP_MULTISAMPLE_9X\n" 
"	#define HAS_OMNIMAP_MULTISAMPLE 1\n" 
"#endif\n" 
"#ifdef HAS_OMNIMAP_MULTISAMPLE_9X\n" 
"vec4 MultiSampleVec(sampler2D  tex , vec2 UV) {\n" 
"	vec3 offset = vec3(-.5,0,.5);\n" 
"	vec2 offsetNormalized = vec2(-0.70710678118*.5,0.70710678118*.5);\n" 
"	vec2 DUV = fwidth(UV);\n" 
"	vec4 mainColor = (\n" 
"		texture2D(tex, UV + DUV *offsetNormalized.xy ) +\n" 
"		texture2D(tex, UV + DUV *offset.yz) +\n" 
"		texture2D(tex, UV + DUV *offsetNormalized.yy) +\n" 
"					\n" 
"		texture2D(tex, UV + DUV *offset.xy) +\n" 
"		texture2D(tex, UV)+\n" 
"		texture2D(tex, UV + DUV *offset.zy) +\n" 
"					\n" 
"		texture2D(tex, UV + DUV *offsetNormalized.xx)+\n" 
"		texture2D(tex, UV + DUV *offset.yx)+\n" 
"		texture2D(tex, UV + DUV *offsetNormalized.yx) \n" 
"	)*.111111111111111;\n" 
"	mainColor.x = 1;\n" 
"	return mainColor;\n" 
"}\n" 
"#endif\n" 
"#ifdef HAS_OMNIMAP_MULTISAMPLE\n" 
"	#define MULTISAMPLE_Vin_Vout(t,uv) MultiSampleVec((t),(uv))\n" 
"#else\n" 
"	#define MULTISAMPLE_Vin_Vout(t,uv) texture2D((t),(uv))\n" 
"#endif\n" 
"//  [ ] Idea for making faster...\n" 
"//       Use projective texturing....\n" 
"//       Prerender texture coordinates\n" 
"//       or compute the texture coordinates in the vertex shader\n" 
"//       Or create a two linear equations that convert ray.xyz1 -> texcoord.uv\n" 
"//const int MaxChannels = 3;\n" 
"//#define MaxChannels 3\n" 
"varying vec2 PixelPos;\n" 
"//uniform sampler2D channelTextures[MaxChannels];	//The images from the seperate RenderChannels\n" 
"uniform sampler2D channelTexture0;\n" 
"uniform sampler2D channelTexture1;\n" 
"uniform sampler2D channelTexture2;\n" 
"uniform sampler2D channelTexture3;\n" 
"//uniform sampler2D channelTexture4;\n" 
"//uniform sampler2D channelTexture5;\n" 
"uniform bool stencilMaskEnabled;\n" 
"uniform sampler2D StencilMask;\n" 
"varying vec3 VertexPosition_WorldSpace;\n" 
"varying float R;\n" 
"//varying vec4  mgl_TexCoord[MaxChannels]; \n" 
"//varying vec4 tc0;\n" 
"//varying vec4 tc1;\n" 
"//varying vec4 tc2;\n" 
"//varying vec4 tc3;\n" 
"//varying vec4 tc4;\n" 
"//varying vec4 tc5;\n" 
"void main()\n" 
"{\n" 
"	\n" 
"	gl_FragColor.rgba = vec4(0.0, 0.0, 0.0, 1.0);\n" 
"	// redo this with projective texturing....\n" 
"	if(R<=1.0)\n" 
"	{\n" 
"		for(int i = 0; i < MaxChannels; i++)	\n" 
"		{\n" 
"			\n" 
"					vec3 texCoords;\n" 
"					if (i == 0)\n" 
"					{\n" 
"						if (gl_TexCoord[0].w > 0.0)\n" 
"						{\n" 
"							texCoords = gl_TexCoord[0].xyz / gl_TexCoord[0].w;\n" 
"							if (texCoords.s >= 0.0 && texCoords.s <= 1.0 &&\n" 
"								texCoords.t >= 0.0 && texCoords.t <= 1.0)\n" 
"								gl_FragColor.rgba = MULTISAMPLE_Vin_Vout(channelTexture0, texCoords.st).rgba;\n" 
"								//gl_FragColor.rgba = vec4(texCoords.s, texCoords.t, 0.0, 1.0);\n" 
"						}\n" 
"					} else if (i == 1) \n" 
"					{\n" 
"						if (gl_TexCoord[1].w > 0.0)\n" 
"						{\n" 
"							texCoords = gl_TexCoord[1].xyz / gl_TexCoord[1].w;\n" 
"							if (texCoords.s >= 0.0 && texCoords.s <= 1.0 &&\n" 
"								texCoords.t >= 0.0 && texCoords.t <= 1.0)\n" 
"								gl_FragColor.rgba = MULTISAMPLE_Vin_Vout(channelTexture1, texCoords.st).rgba;\n" 
"								//gl_FragColor.rgba = vec4(texCoords.s, texCoords.t, 0.0, 1.0);\n" 
"						}\n" 
"					} else if (i == 2)\n" 
"					{\n" 
"						if (gl_TexCoord[2].w > 0.0)\n" 
"						{\n" 
"							texCoords = gl_TexCoord[2].xyz / gl_TexCoord[2].w;\n" 
"							if (texCoords.s >= 0.0 && texCoords.s <= 1.0 &&\n" 
"								texCoords.t >= 0.0 && texCoords.t <= 1.0)\n" 
"								gl_FragColor.rgba = MULTISAMPLE_Vin_Vout(channelTexture2, texCoords.st).rgba;\n" 
"								//gl_FragColor.rgba = vec4(texCoords.s, texCoords.t, 0.0, 1.0);\n" 
"						}\n" 
"					} else if (i == 3)\n" 
"					{\n" 
"						if (gl_TexCoord[3].w > 0.0)\n" 
"						{\n" 
"							texCoords = gl_TexCoord[3].xyz / gl_TexCoord[3].w;\n" 
"							if (texCoords.s >= 0.0 && texCoords.s <= 1.0 &&\n" 
"								texCoords.t >= 0.0 && texCoords.t <= 1.0)\n" 
"								gl_FragColor.rgba = MULTISAMPLE_Vin_Vout(channelTexture3, texCoords.st).rgba;\n" 
"						}\n" 
"					}// else if (i == 4)\n" 
"					//{\n" 
"						//if (tc4.w > 0.0)\n" 
"						//{\n" 
"							//texCoords = tc4.xyz / tc4.w;\n" 
"							//if (texCoords.s >= 0.0 && texCoords.s <= 1.0 &&\n" 
"								//texCoords.t >= 0.0 && texCoords.t <= 1.0)\n" 
"								//gl_FragColor.rgba = MULTISAMPLE_Vin_Vout(channelTexture4, texCoords.st).rgba;\n" 
"						//}\n" 
"					//} else if (i == 5)\n" 
"					//{\n" 
"						//if (tc5.w > 0.0)\n" 
"						//{\n" 
"							//texCoords = tc5.xyz / tc5.w;\n" 
"							//if (texCoords.s >= 0.0 && texCoords.s <= 1.0 &&\n" 
"								//texCoords.t >= 0.0 && texCoords.t <= 1.0)\n" 
"								//gl_FragColor.rgba = MULTISAMPLE_Vin_Vout(channelTexture5, texCoords.st).rgba;\n" 
"						//}\n" 
"					//}\n" 
"						\n" 
"				\n" 
"	\n" 
"		}\n" 
"	}\n" 
"	//if the mask color is zero we could try doing an early branch exit so we can skip the projective texturing phase..\n" 
"	if (stencilMaskEnabled)\n" 
"		gl_FragColor.xyz = gl_FragColor.xyz * texture2D(StencilMask,PixelPos.xy).xyz;\n" 
"}\n" 
}; 
